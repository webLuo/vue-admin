<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Promise</title>
</head>

<body>
  <script>
    // resolve reject all race
    // resolve = then reject = catch
    // let promise = new Promise((resolve, reject) => {
    //   // reject()
    //   // resolve(111)
    //   reject(222)
    // })
    // promise.then(response => {
    //   console.log('success')
    //   console.log(response)
    // }).catch(error => {
    //   console.log('defeat')
    //   console.log(error)
    // })

    // 链式
    function promise1(status) {
      return new Promise((resolve, reject) => {
        if (status) {
          console.log('第1个promise成功')
          resolve('第1个promise返回数据成功')
        }
        if (!status) {
          console.log('第1个promise失败')
          reject('第1个promise返回数据失败')
        }
      })
    }

    function promise2(status) {
      return new Promise((resolve, reject) => {
        if (status) {
          console.log('第2个promise成功')
          resolve('第2个promise返回数据成功')
        }
        if (!status) {
          console.log('第2个promise失败')
          reject('第2个promise返回数据失败')
        }
      })
    }

    function promise3(status) {
      return new Promise((resolve, reject) => {
        if (status) {
          console.log('第3个promise成功')
          resolve('第3个promise返回数据成功')
        }
        if (!status) {
          console.log('第3个promise失败')
          reject('第3个promise返回数据失败')
        }
      })
    }
    // promise1(true).then(response => {
    //   console.log(response)
    //   promise2(true)
    // }).catch(error => {
    //   console.log(error)
    // })

    // promise1(true).then(response => {
    //   console.log(response)
    //   return promise2(true)
    // }).then(response => {
    //   console.log(response)
    // }).catch(error => {
    //   console.log(error)
    // })

    // 链式有一个进入catch则不再往下进行链式调用
    // promise1(true).then(response => {
    //   console.log(response)
    //   return promise2(true)
    // }).then(response => {
    //   console.log(response)
    //   return promise3(false)
    // }).then(response => {
    //   console.log(response)
    // }).catch(error => {
    //   console.log(error)
    // })

    // all
    // all方法，数组内promise必须全部成功（全部返回resolve），才会执行then的回调，只要有一个返回（reject）就不成功，就会执行reject
    // Promise.all([promise1(false), promise2(true)]).then(response => {
    //   console.log(response)
    //   console.log('全部调用成功')
    // }).catch(error => {
    //   console.log(error)
    //   console.log('有些可能失败了')
    // })

    // race,在执行的时候，遇到的返回结果是resolve(成功)，一直执行链式。
    // 只要有一个返回resolve，会代表成功，就会调用then，但是，如果第一个返回reject，那么就失败了
    Promise.race([promise1(true), promise2(true), promise3(true)]).then(response => {
      console.log(response)
      console.log('全部调用成功')
    }).catch(error => {
      console.log(error)
      console.log('有些可能失败了')
    })
  </script>
</body>

</html>